// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Vector3, Vector3T } from '../../flat/flat/vector3.js';


/**
 * Information about a ball touch.
 */
export class Touch implements flatbuffers.IUnpackableObject<TouchT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Touch {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTouch(bb:flatbuffers.ByteBuffer, obj?:Touch):Touch {
  return (obj || new Touch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTouch(bb:flatbuffers.ByteBuffer, obj?:Touch):Touch {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Touch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Seconds that had elapsed in the game when the touch occurred.
 */
gameSeconds():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The point of contact for the touch.
 */
location(obj?:Vector3):Vector3|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Vector3()).__init(this.bb_pos + offset, this.bb!) : null;
}

/**
 * The direction of the touch as a unit vector pointing from the point of contact towards the center of the ball.
 */
normal(obj?:Vector3):Vector3|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new Vector3()).__init(this.bb_pos + offset, this.bb!) : null;
}

/**
 * The index of the ball that was touched (in case there are multiple balls).
 */
ballIndex():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

static startTouch(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addGameSeconds(builder:flatbuffers.Builder, gameSeconds:number) {
  builder.addFieldFloat32(0, gameSeconds, 0.0);
}

static addLocation(builder:flatbuffers.Builder, locationOffset:flatbuffers.Offset) {
  builder.addFieldStruct(1, locationOffset, 0);
}

static addNormal(builder:flatbuffers.Builder, normalOffset:flatbuffers.Offset) {
  builder.addFieldStruct(2, normalOffset, 0);
}

static addBallIndex(builder:flatbuffers.Builder, ballIndex:number) {
  builder.addFieldInt32(3, ballIndex, 0);
}

static endTouch(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 6) // location
  builder.requiredField(offset, 8) // normal
  return offset;
}


unpack(): TouchT {
  return new TouchT(
    this.gameSeconds(),
    (this.location() !== null ? this.location()!.unpack() : null),
    (this.normal() !== null ? this.normal()!.unpack() : null),
    this.ballIndex()
  );
}


unpackTo(_o: TouchT): void {
  _o.gameSeconds = this.gameSeconds();
  _o.location = (this.location() !== null ? this.location()!.unpack() : null);
  _o.normal = (this.normal() !== null ? this.normal()!.unpack() : null);
  _o.ballIndex = this.ballIndex();
}
}

export class TouchT implements flatbuffers.IGeneratedObject {
constructor(
  public gameSeconds: number = 0.0,
  public location: Vector3T|null = null,
  public normal: Vector3T|null = null,
  public ballIndex: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  Touch.startTouch(builder);
  Touch.addGameSeconds(builder, this.gameSeconds);
  Touch.addLocation(builder, (this.location !== null ? this.location!.pack(builder) : 0));
  Touch.addNormal(builder, (this.normal !== null ? this.normal!.pack(builder) : 0));
  Touch.addBallIndex(builder, this.ballIndex);

  return Touch.endTouch(builder);
}
}
