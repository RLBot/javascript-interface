// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { MatchPhase } from '../../flat/flat/match-phase.js';


/**
 * Information about the current match such as time and gravity.
 */
export class MatchInfo implements flatbuffers.IUnpackableObject<MatchInfoT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):MatchInfo {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMatchInfo(bb:flatbuffers.ByteBuffer, obj?:MatchInfo):MatchInfo {
  return (obj || new MatchInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMatchInfo(bb:flatbuffers.ByteBuffer, obj?:MatchInfo):MatchInfo {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * How many seconds have elapsed since the first game packet of the match.
 * This value ticks up even during kickoffs, replays, pause, etc.
 */
secondsElapsed():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Seconds remaining of the match.
 * This value ticks up instead of down during overtime or when the game duration mutator is set to Unlimited.
 * I.e. it matches the in-game timer at the top.
 */
gameTimeRemaining():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * True if the game is in overtime.
 */
isOvertime():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if the game duration is set to Unlimited.
 */
isUnlimitedTime():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The current phase of the match, i.e. kickoff, replay, active, etc.
 */
matchPhase():MatchPhase {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : MatchPhase.Inactive;
}

/**
 * The current strength of gravity. Default is -650.
 */
worldGravityZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Game speed multiplier. Regular game speed is 1.0.
 */
gameSpeed():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Index of the player who was most recently a spectated by the host.
 */
lastSpectated():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Tracks the number of physics frames the game has computed.
 * May increase by more than one across consecutive packets.
 * Data type will roll over after 414 days at 120Hz.
 */
frameNum():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

static startMatchInfo(builder:flatbuffers.Builder) {
  builder.startObject(9);
}

static addSecondsElapsed(builder:flatbuffers.Builder, secondsElapsed:number) {
  builder.addFieldFloat32(0, secondsElapsed, 0.0);
}

static addGameTimeRemaining(builder:flatbuffers.Builder, gameTimeRemaining:number) {
  builder.addFieldFloat32(1, gameTimeRemaining, 0.0);
}

static addIsOvertime(builder:flatbuffers.Builder, isOvertime:boolean) {
  builder.addFieldInt8(2, +isOvertime, +false);
}

static addIsUnlimitedTime(builder:flatbuffers.Builder, isUnlimitedTime:boolean) {
  builder.addFieldInt8(3, +isUnlimitedTime, +false);
}

static addMatchPhase(builder:flatbuffers.Builder, matchPhase:MatchPhase) {
  builder.addFieldInt8(4, matchPhase, MatchPhase.Inactive);
}

static addWorldGravityZ(builder:flatbuffers.Builder, worldGravityZ:number) {
  builder.addFieldFloat32(5, worldGravityZ, 0.0);
}

static addGameSpeed(builder:flatbuffers.Builder, gameSpeed:number) {
  builder.addFieldFloat32(6, gameSpeed, 0.0);
}

static addLastSpectated(builder:flatbuffers.Builder, lastSpectated:number) {
  builder.addFieldInt32(7, lastSpectated, 0);
}

static addFrameNum(builder:flatbuffers.Builder, frameNum:number) {
  builder.addFieldInt32(8, frameNum, 0);
}

static endMatchInfo(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createMatchInfo(builder:flatbuffers.Builder, secondsElapsed:number, gameTimeRemaining:number, isOvertime:boolean, isUnlimitedTime:boolean, matchPhase:MatchPhase, worldGravityZ:number, gameSpeed:number, lastSpectated:number, frameNum:number):flatbuffers.Offset {
  MatchInfo.startMatchInfo(builder);
  MatchInfo.addSecondsElapsed(builder, secondsElapsed);
  MatchInfo.addGameTimeRemaining(builder, gameTimeRemaining);
  MatchInfo.addIsOvertime(builder, isOvertime);
  MatchInfo.addIsUnlimitedTime(builder, isUnlimitedTime);
  MatchInfo.addMatchPhase(builder, matchPhase);
  MatchInfo.addWorldGravityZ(builder, worldGravityZ);
  MatchInfo.addGameSpeed(builder, gameSpeed);
  MatchInfo.addLastSpectated(builder, lastSpectated);
  MatchInfo.addFrameNum(builder, frameNum);
  return MatchInfo.endMatchInfo(builder);
}

unpack(): MatchInfoT {
  return new MatchInfoT(
    this.secondsElapsed(),
    this.gameTimeRemaining(),
    this.isOvertime(),
    this.isUnlimitedTime(),
    this.matchPhase(),
    this.worldGravityZ(),
    this.gameSpeed(),
    this.lastSpectated(),
    this.frameNum()
  );
}


unpackTo(_o: MatchInfoT): void {
  _o.secondsElapsed = this.secondsElapsed();
  _o.gameTimeRemaining = this.gameTimeRemaining();
  _o.isOvertime = this.isOvertime();
  _o.isUnlimitedTime = this.isUnlimitedTime();
  _o.matchPhase = this.matchPhase();
  _o.worldGravityZ = this.worldGravityZ();
  _o.gameSpeed = this.gameSpeed();
  _o.lastSpectated = this.lastSpectated();
  _o.frameNum = this.frameNum();
}
}

export class MatchInfoT implements flatbuffers.IGeneratedObject {
constructor(
  public secondsElapsed: number = 0.0,
  public gameTimeRemaining: number = 0.0,
  public isOvertime: boolean = false,
  public isUnlimitedTime: boolean = false,
  public matchPhase: MatchPhase = MatchPhase.Inactive,
  public worldGravityZ: number = 0.0,
  public gameSpeed: number = 0.0,
  public lastSpectated: number = 0,
  public frameNum: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return MatchInfo.createMatchInfo(builder,
    this.secondsElapsed,
    this.gameTimeRemaining,
    this.isOvertime,
    this.isUnlimitedTime,
    this.matchPhase,
    this.worldGravityZ,
    this.gameSpeed,
    this.lastSpectated,
    this.frameNum
  );
}
}
