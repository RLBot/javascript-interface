// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * A message sent to other bots and scripts through RLBot.
 * Use the team_only field if the message should only be received by team mates.
 * The message can also have a human-readable summary displayed in quick chat through the display field.
 */
export class MatchComm implements flatbuffers.IUnpackableObject<MatchCommT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):MatchComm {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMatchComm(bb:flatbuffers.ByteBuffer, obj?:MatchComm):MatchComm {
  return (obj || new MatchComm()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMatchComm(bb:flatbuffers.ByteBuffer, obj?:MatchComm):MatchComm {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchComm()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * The index of the player that sent this message.
 * For scripts, this value is the index in the match configuration instead.
 */
index():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * The team of the player that sent this message.
 * For scripts, this value is 2.
 */
team():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * True if this message is team-only, false if everyone can see it
 */
teamOnly():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The message that will be displayed on the screen in quick chat.
 * This is intended for communication with humans.
 * Use the content field for communication with bots and scripts.
 */
display():string|null
display(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
display(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The contents of the message.
 * Use the display field for messages in quick chat.
 */
content(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

contentLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

contentArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startMatchComm(builder:flatbuffers.Builder) {
  builder.startObject(5);
}

static addIndex(builder:flatbuffers.Builder, index:number) {
  builder.addFieldInt32(0, index, 0);
}

static addTeam(builder:flatbuffers.Builder, team:number) {
  builder.addFieldInt32(1, team, 0);
}

static addTeamOnly(builder:flatbuffers.Builder, teamOnly:boolean) {
  builder.addFieldInt8(2, +teamOnly, +false);
}

static addDisplay(builder:flatbuffers.Builder, displayOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, displayOffset, 0);
}

static addContent(builder:flatbuffers.Builder, contentOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, contentOffset, 0);
}

static createContentVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startContentVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endMatchComm(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 12) // content
  return offset;
}

static createMatchComm(builder:flatbuffers.Builder, index:number, team:number, teamOnly:boolean, displayOffset:flatbuffers.Offset, contentOffset:flatbuffers.Offset):flatbuffers.Offset {
  MatchComm.startMatchComm(builder);
  MatchComm.addIndex(builder, index);
  MatchComm.addTeam(builder, team);
  MatchComm.addTeamOnly(builder, teamOnly);
  MatchComm.addDisplay(builder, displayOffset);
  MatchComm.addContent(builder, contentOffset);
  return MatchComm.endMatchComm(builder);
}

unpack(): MatchCommT {
  return new MatchCommT(
    this.index(),
    this.team(),
    this.teamOnly(),
    this.display(),
    this.bb!.createScalarList<number>(this.content.bind(this), this.contentLength())
  );
}


unpackTo(_o: MatchCommT): void {
  _o.index = this.index();
  _o.team = this.team();
  _o.teamOnly = this.teamOnly();
  _o.display = this.display();
  _o.content = this.bb!.createScalarList<number>(this.content.bind(this), this.contentLength());
}
}

export class MatchCommT implements flatbuffers.IGeneratedObject {
constructor(
  public index: number = 0,
  public team: number = 0,
  public teamOnly: boolean = false,
  public display: string|Uint8Array|null = null,
  public content: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const display = (this.display !== null ? builder.createString(this.display!) : 0);
  const content = MatchComm.createContentVector(builder, this.content);

  return MatchComm.createMatchComm(builder,
    this.index,
    this.team,
    this.teamOnly,
    display,
    content
  );
}
}
