// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { BallInfo, BallInfoT } from '../../flat/flat/ball-info.js';
import { BoostPadState, BoostPadStateT } from '../../flat/flat/boost-pad-state.js';
import { MatchInfo, MatchInfoT } from '../../flat/flat/match-info.js';
import { PlayerInfo, PlayerInfoT } from '../../flat/flat/player-info.js';
import { TeamInfo, TeamInfoT } from '../../flat/flat/team-info.js';


/**
 * A packet of data from the game.
 * Is is sent every tick to bots, scripts, etc.
 * Static data is found in the FieldInfo.
 */
export class GamePacket implements flatbuffers.IUnpackableObject<GamePacketT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GamePacket {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGamePacket(bb:flatbuffers.ByteBuffer, obj?:GamePacket):GamePacket {
  return (obj || new GamePacket()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGamePacket(bb:flatbuffers.ByteBuffer, obj?:GamePacket):GamePacket {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GamePacket()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * The current state of all players and their cars.
 */
players(index: number, obj?:PlayerInfo):PlayerInfo|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new PlayerInfo()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

playersLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The current state of all boost pads.
 * The static information about boost pads are found in the FieldInfo.
 * The boost pads are ordered by y-coordinate and then x-coordinate.
 */
boostPads(index: number, obj?:BoostPadState):BoostPadState|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new BoostPadState()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 8, this.bb!) : null;
}

boostPadsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The current state of all balls.
 */
balls(index: number, obj?:BallInfo):BallInfo|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new BallInfo()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

ballsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The current state of the match such as timers and gravity.
 */
matchInfo(obj?:MatchInfo):MatchInfo|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new MatchInfo()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * The current state of teams, i.e. the team scores.
 */
teams(index: number, obj?:TeamInfo):TeamInfo|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new TeamInfo()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 8, this.bb!) : null;
}

teamsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startGamePacket(builder:flatbuffers.Builder) {
  builder.startObject(5);
}

static addPlayers(builder:flatbuffers.Builder, playersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, playersOffset, 0);
}

static createPlayersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startPlayersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addBoostPads(builder:flatbuffers.Builder, boostPadsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, boostPadsOffset, 0);
}

static startBoostPadsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 4);
}

static addBalls(builder:flatbuffers.Builder, ballsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, ballsOffset, 0);
}

static createBallsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBallsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addMatchInfo(builder:flatbuffers.Builder, matchInfoOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, matchInfoOffset, 0);
}

static addTeams(builder:flatbuffers.Builder, teamsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, teamsOffset, 0);
}

static startTeamsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 4);
}

static endGamePacket(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // players
  builder.requiredField(offset, 6) // boost_pads
  builder.requiredField(offset, 8) // balls
  builder.requiredField(offset, 10) // match_info
  builder.requiredField(offset, 12) // teams
  return offset;
}


unpack(): GamePacketT {
  return new GamePacketT(
    this.bb!.createObjList<PlayerInfo, PlayerInfoT>(this.players.bind(this), this.playersLength()),
    this.bb!.createObjList<BoostPadState, BoostPadStateT>(this.boostPads.bind(this), this.boostPadsLength()),
    this.bb!.createObjList<BallInfo, BallInfoT>(this.balls.bind(this), this.ballsLength()),
    (this.matchInfo() !== null ? this.matchInfo()!.unpack() : null),
    this.bb!.createObjList<TeamInfo, TeamInfoT>(this.teams.bind(this), this.teamsLength())
  );
}


unpackTo(_o: GamePacketT): void {
  _o.players = this.bb!.createObjList<PlayerInfo, PlayerInfoT>(this.players.bind(this), this.playersLength());
  _o.boostPads = this.bb!.createObjList<BoostPadState, BoostPadStateT>(this.boostPads.bind(this), this.boostPadsLength());
  _o.balls = this.bb!.createObjList<BallInfo, BallInfoT>(this.balls.bind(this), this.ballsLength());
  _o.matchInfo = (this.matchInfo() !== null ? this.matchInfo()!.unpack() : null);
  _o.teams = this.bb!.createObjList<TeamInfo, TeamInfoT>(this.teams.bind(this), this.teamsLength());
}
}

export class GamePacketT implements flatbuffers.IGeneratedObject {
constructor(
  public players: (PlayerInfoT)[] = [],
  public boostPads: (BoostPadStateT)[] = [],
  public balls: (BallInfoT)[] = [],
  public matchInfo: MatchInfoT|null = null,
  public teams: (TeamInfoT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const players = GamePacket.createPlayersVector(builder, builder.createObjectOffsetList(this.players));
  const boostPads = builder.createStructOffsetList(this.boostPads, GamePacket.startBoostPadsVector);
  const balls = GamePacket.createBallsVector(builder, builder.createObjectOffsetList(this.balls));
  const matchInfo = (this.matchInfo !== null ? this.matchInfo!.pack(builder) : 0);
  const teams = builder.createStructOffsetList(this.teams, GamePacket.startTeamsVector);

  GamePacket.startGamePacket(builder);
  GamePacket.addPlayers(builder, players);
  GamePacket.addBoostPads(builder, boostPads);
  GamePacket.addBalls(builder, balls);
  GamePacket.addMatchInfo(builder, matchInfo);
  GamePacket.addTeams(builder, teams);

  return GamePacket.endGamePacket(builder);
}
}
