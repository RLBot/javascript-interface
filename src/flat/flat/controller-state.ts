// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * A combination of button presses and analog steering values like those produced by a physical controller or keyboard.
 * This is sent by bots each tick to RLBot to indicate what they want to do that tick.
 * For example, if you want to hold the jump button for 20 ticks, then you must send 20 controller states where jump is true.
 * Remember to send controller states with jump set to false to let go of the jump button afterwards.
 */
export class ControllerState implements flatbuffers.IUnpackableObject<ControllerStateT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ControllerState {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

/**
 * -1 for full reverse, 1 for full forward.
 */
throttle():number {
  return this.bb!.readFloat32(this.bb_pos);
}

/**
 * -1 for full left, 1 for full right.
 */
steer():number {
  return this.bb!.readFloat32(this.bb_pos + 4);
}

/**
 * -1 for nose down, 1 for nose up.
 */
pitch():number {
  return this.bb!.readFloat32(this.bb_pos + 8);
}

/**
 * -1 for full left, 1 for full right.
 */
yaw():number {
  return this.bb!.readFloat32(this.bb_pos + 12);
}

/**
 * -1 for roll left, 1 for roll right.
 */
roll():number {
  return this.bb!.readFloat32(this.bb_pos + 16);
}

/**
 * True if you want to press the jump button.
 */
jump():boolean {
  return !!this.bb!.readInt8(this.bb_pos + 20);
}

/**
 * True if you want to press the boost button.
 */
boost():boolean {
  return !!this.bb!.readInt8(this.bb_pos + 21);
}

/**
 * True if you want to press the handbrake button.
 */
handbrake():boolean {
  return !!this.bb!.readInt8(this.bb_pos + 22);
}

/**
 * True if you want to press the 'use item' button. Used in Rumble and other game modes.
 */
useItem():boolean {
  return !!this.bb!.readInt8(this.bb_pos + 23);
}

static sizeOf():number {
  return 24;
}

static createControllerState(builder:flatbuffers.Builder, throttle: number, steer: number, pitch: number, yaw: number, roll: number, jump: boolean, boost: boolean, handbrake: boolean, use_item: boolean):flatbuffers.Offset {
  builder.prep(4, 24);
  builder.writeInt8(Number(Boolean(use_item)));
  builder.writeInt8(Number(Boolean(handbrake)));
  builder.writeInt8(Number(Boolean(boost)));
  builder.writeInt8(Number(Boolean(jump)));
  builder.writeFloat32(roll);
  builder.writeFloat32(yaw);
  builder.writeFloat32(pitch);
  builder.writeFloat32(steer);
  builder.writeFloat32(throttle);
  return builder.offset();
}


unpack(): ControllerStateT {
  return new ControllerStateT(
    this.throttle(),
    this.steer(),
    this.pitch(),
    this.yaw(),
    this.roll(),
    this.jump(),
    this.boost(),
    this.handbrake(),
    this.useItem()
  );
}


unpackTo(_o: ControllerStateT): void {
  _o.throttle = this.throttle();
  _o.steer = this.steer();
  _o.pitch = this.pitch();
  _o.yaw = this.yaw();
  _o.roll = this.roll();
  _o.jump = this.jump();
  _o.boost = this.boost();
  _o.handbrake = this.handbrake();
  _o.useItem = this.useItem();
}
}

export class ControllerStateT implements flatbuffers.IGeneratedObject {
constructor(
  public throttle: number = 0.0,
  public steer: number = 0.0,
  public pitch: number = 0.0,
  public yaw: number = 0.0,
  public roll: number = 0.0,
  public jump: boolean = false,
  public boost: boolean = false,
  public handbrake: boolean = false,
  public useItem: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return ControllerState.createControllerState(builder,
    this.throttle,
    this.steer,
    this.pitch,
    this.yaw,
    this.roll,
    this.jump,
    this.boost,
    this.handbrake,
    this.useItem
  );
}
}
