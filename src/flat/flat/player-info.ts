// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { AirState } from '../../flat/flat/air-state.js';
import { BoxShape, BoxShapeT } from '../../flat/flat/box-shape.js';
import { ControllerState, ControllerStateT } from '../../flat/flat/controller-state.js';
import { Physics, PhysicsT } from '../../flat/flat/physics.js';
import { ScoreInfo, ScoreInfoT } from '../../flat/flat/score-info.js';
import { Touch, TouchT } from '../../flat/flat/touch.js';
import { Vector2, Vector2T } from '../../flat/flat/vector2.js';
import { Vector3, Vector3T } from '../../flat/flat/vector3.js';


/**
 * A collection of information about a player and their car.
 */
export class PlayerInfo implements flatbuffers.IUnpackableObject<PlayerInfoT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PlayerInfo {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPlayerInfo(bb:flatbuffers.ByteBuffer, obj?:PlayerInfo):PlayerInfo {
  return (obj || new PlayerInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPlayerInfo(bb:flatbuffers.ByteBuffer, obj?:PlayerInfo):PlayerInfo {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PlayerInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * The physical state of the player's car.
 */
physics(obj?:Physics):Physics|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new Physics()).__init(this.bb_pos + offset, this.bb!) : null;
}

/**
 * The various scores of this player, e.g. those on the leaderboard.
 */
scoreInfo(obj?:ScoreInfo):ScoreInfo|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new ScoreInfo()).__init(this.bb_pos + offset, this.bb!) : null;
}

/**
 * The hitbox of the player's car.
 * Note that the hitbox is not centered at the cars location.
 * See the hitbox offset.
 */
hitbox(obj?:BoxShape):BoxShape|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new BoxShape()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * The center of the hitbox in local coordinates.
 */
hitboxOffset(obj?:Vector3):Vector3|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new Vector3()).__init(this.bb_pos + offset, this.bb!) : null;
}

/**
 * Information about the latest touch with a ball.
 * Is null if the player has yet to touch the ball.
 */
latestTouch(obj?:Touch):Touch|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new Touch()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Whether the player's car is on the ground or in the air, and what jump/dodging forces currently affects the car.
 */
airState():AirState {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : AirState.OnGround;
}

/**
 * How long until the player cannot dodge/double jump anymore.
 * The value is -1 while on ground or when airborne for too long after jumping.
 * A dodge/double jump is possible for 1.25 seconds after the first jump plus
 * up to an additional 0.2 seconds depending how long the jump button was pressed for the first jump.
 */
dodgeTimeout():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * How long until the player is not demolished anymore.
 * The value is -1 if while not demolished.
 */
demolishedTimeout():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Whether the player's car is moving at supersonic speed and can demolish.
 */
isSupersonic():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Whether the player is a bot or a human.
 */
isBot():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The name of the player as it appears in game, i.e. possibly appended with "(2)".
 * The original name can be found in the match configuration.
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The team of the player.
 */
team():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * The current boost, from 0 to 100.
 */
boost():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The id of the player.
 * This value is mostly used internally to keep track of participants in the match.
 * The id can be used to find the corresponding PlayerConfiguration in the MatchConfiguration.
 */
playerId():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Events from the latest tick involving this player. Possible values include:
 *    Win, Loss, TimePlayed;
 *    Shot, Assist, Center, Clear, PoolShot;
 *    Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
 *    AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
 *    Save, EpicSave, FreezeSave;
 *    HatTrick, Savior, Playmaker, MVP;
 *    FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
 *    MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
 *    CarTouches, Demolition, Demolish;
 *    LowFive, HighFive;
 * Note that the list clears every tick.
 */
accolades(index: number):string
accolades(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
accolades(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

accoladesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The last controller input from this player.
 */
lastInput(obj?:ControllerState):ControllerState|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? (obj || new ControllerState()).__init(this.bb_pos + offset, this.bb!) : null;
}

/**
 * True if the player has jumped. See dodge_timeout to know if a dodge/secondary jump is available.
 */
hasJumped():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if the player has doubled jumped.
 */
hasDoubleJumped():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if the player has dodged.
 */
hasDodged():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The time in seconds since the last dodge was initiated.
 * Resets to 0 when the player lands on the ground.
 */
dodgeElapsed():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The unit direction of the latest dodge.
 * The value will be (0,0) if it was a stall.
 */
dodgeDir(obj?:Vector2):Vector2|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? (obj || new Vector2()).__init(this.bb_pos + offset, this.bb!) : null;
}

static startPlayerInfo(builder:flatbuffers.Builder) {
  builder.startObject(21);
}

static addPhysics(builder:flatbuffers.Builder, physicsOffset:flatbuffers.Offset) {
  builder.addFieldStruct(0, physicsOffset, 0);
}

static addScoreInfo(builder:flatbuffers.Builder, scoreInfoOffset:flatbuffers.Offset) {
  builder.addFieldStruct(1, scoreInfoOffset, 0);
}

static addHitbox(builder:flatbuffers.Builder, hitboxOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, hitboxOffset, 0);
}

static addHitboxOffset(builder:flatbuffers.Builder, hitboxOffsetOffset:flatbuffers.Offset) {
  builder.addFieldStruct(3, hitboxOffsetOffset, 0);
}

static addLatestTouch(builder:flatbuffers.Builder, latestTouchOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, latestTouchOffset, 0);
}

static addAirState(builder:flatbuffers.Builder, airState:AirState) {
  builder.addFieldInt8(5, airState, AirState.OnGround);
}

static addDodgeTimeout(builder:flatbuffers.Builder, dodgeTimeout:number) {
  builder.addFieldFloat32(6, dodgeTimeout, 0.0);
}

static addDemolishedTimeout(builder:flatbuffers.Builder, demolishedTimeout:number) {
  builder.addFieldFloat32(7, demolishedTimeout, 0.0);
}

static addIsSupersonic(builder:flatbuffers.Builder, isSupersonic:boolean) {
  builder.addFieldInt8(8, +isSupersonic, +false);
}

static addIsBot(builder:flatbuffers.Builder, isBot:boolean) {
  builder.addFieldInt8(9, +isBot, +false);
}

static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, nameOffset, 0);
}

static addTeam(builder:flatbuffers.Builder, team:number) {
  builder.addFieldInt32(11, team, 0);
}

static addBoost(builder:flatbuffers.Builder, boost:number) {
  builder.addFieldFloat32(12, boost, 0.0);
}

static addPlayerId(builder:flatbuffers.Builder, playerId:number) {
  builder.addFieldInt32(13, playerId, 0);
}

static addAccolades(builder:flatbuffers.Builder, accoladesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, accoladesOffset, 0);
}

static createAccoladesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAccoladesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLastInput(builder:flatbuffers.Builder, lastInputOffset:flatbuffers.Offset) {
  builder.addFieldStruct(15, lastInputOffset, 0);
}

static addHasJumped(builder:flatbuffers.Builder, hasJumped:boolean) {
  builder.addFieldInt8(16, +hasJumped, +false);
}

static addHasDoubleJumped(builder:flatbuffers.Builder, hasDoubleJumped:boolean) {
  builder.addFieldInt8(17, +hasDoubleJumped, +false);
}

static addHasDodged(builder:flatbuffers.Builder, hasDodged:boolean) {
  builder.addFieldInt8(18, +hasDodged, +false);
}

static addDodgeElapsed(builder:flatbuffers.Builder, dodgeElapsed:number) {
  builder.addFieldFloat32(19, dodgeElapsed, 0.0);
}

static addDodgeDir(builder:flatbuffers.Builder, dodgeDirOffset:flatbuffers.Offset) {
  builder.addFieldStruct(20, dodgeDirOffset, 0);
}

static endPlayerInfo(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // physics
  builder.requiredField(offset, 6) // score_info
  builder.requiredField(offset, 8) // hitbox
  builder.requiredField(offset, 10) // hitbox_offset
  builder.requiredField(offset, 24) // name
  builder.requiredField(offset, 32) // accolades
  builder.requiredField(offset, 34) // last_input
  builder.requiredField(offset, 44) // dodge_dir
  return offset;
}


unpack(): PlayerInfoT {
  return new PlayerInfoT(
    (this.physics() !== null ? this.physics()!.unpack() : null),
    (this.scoreInfo() !== null ? this.scoreInfo()!.unpack() : null),
    (this.hitbox() !== null ? this.hitbox()!.unpack() : null),
    (this.hitboxOffset() !== null ? this.hitboxOffset()!.unpack() : null),
    (this.latestTouch() !== null ? this.latestTouch()!.unpack() : null),
    this.airState(),
    this.dodgeTimeout(),
    this.demolishedTimeout(),
    this.isSupersonic(),
    this.isBot(),
    this.name(),
    this.team(),
    this.boost(),
    this.playerId(),
    this.bb!.createScalarList<string>(this.accolades.bind(this), this.accoladesLength()),
    (this.lastInput() !== null ? this.lastInput()!.unpack() : null),
    this.hasJumped(),
    this.hasDoubleJumped(),
    this.hasDodged(),
    this.dodgeElapsed(),
    (this.dodgeDir() !== null ? this.dodgeDir()!.unpack() : null)
  );
}


unpackTo(_o: PlayerInfoT): void {
  _o.physics = (this.physics() !== null ? this.physics()!.unpack() : null);
  _o.scoreInfo = (this.scoreInfo() !== null ? this.scoreInfo()!.unpack() : null);
  _o.hitbox = (this.hitbox() !== null ? this.hitbox()!.unpack() : null);
  _o.hitboxOffset = (this.hitboxOffset() !== null ? this.hitboxOffset()!.unpack() : null);
  _o.latestTouch = (this.latestTouch() !== null ? this.latestTouch()!.unpack() : null);
  _o.airState = this.airState();
  _o.dodgeTimeout = this.dodgeTimeout();
  _o.demolishedTimeout = this.demolishedTimeout();
  _o.isSupersonic = this.isSupersonic();
  _o.isBot = this.isBot();
  _o.name = this.name();
  _o.team = this.team();
  _o.boost = this.boost();
  _o.playerId = this.playerId();
  _o.accolades = this.bb!.createScalarList<string>(this.accolades.bind(this), this.accoladesLength());
  _o.lastInput = (this.lastInput() !== null ? this.lastInput()!.unpack() : null);
  _o.hasJumped = this.hasJumped();
  _o.hasDoubleJumped = this.hasDoubleJumped();
  _o.hasDodged = this.hasDodged();
  _o.dodgeElapsed = this.dodgeElapsed();
  _o.dodgeDir = (this.dodgeDir() !== null ? this.dodgeDir()!.unpack() : null);
}
}

export class PlayerInfoT implements flatbuffers.IGeneratedObject {
constructor(
  public physics: PhysicsT|null = null,
  public scoreInfo: ScoreInfoT|null = null,
  public hitbox: BoxShapeT|null = null,
  public hitboxOffset: Vector3T|null = null,
  public latestTouch: TouchT|null = null,
  public airState: AirState = AirState.OnGround,
  public dodgeTimeout: number = 0.0,
  public demolishedTimeout: number = 0.0,
  public isSupersonic: boolean = false,
  public isBot: boolean = false,
  public name: string|Uint8Array|null = null,
  public team: number = 0,
  public boost: number = 0.0,
  public playerId: number = 0,
  public accolades: (string)[] = [],
  public lastInput: ControllerStateT|null = null,
  public hasJumped: boolean = false,
  public hasDoubleJumped: boolean = false,
  public hasDodged: boolean = false,
  public dodgeElapsed: number = 0.0,
  public dodgeDir: Vector2T|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const hitbox = (this.hitbox !== null ? this.hitbox!.pack(builder) : 0);
  const latestTouch = (this.latestTouch !== null ? this.latestTouch!.pack(builder) : 0);
  const name = (this.name !== null ? builder.createString(this.name!) : 0);
  const accolades = PlayerInfo.createAccoladesVector(builder, builder.createObjectOffsetList(this.accolades));

  PlayerInfo.startPlayerInfo(builder);
  PlayerInfo.addPhysics(builder, (this.physics !== null ? this.physics!.pack(builder) : 0));
  PlayerInfo.addScoreInfo(builder, (this.scoreInfo !== null ? this.scoreInfo!.pack(builder) : 0));
  PlayerInfo.addHitbox(builder, hitbox);
  PlayerInfo.addHitboxOffset(builder, (this.hitboxOffset !== null ? this.hitboxOffset!.pack(builder) : 0));
  PlayerInfo.addLatestTouch(builder, latestTouch);
  PlayerInfo.addAirState(builder, this.airState);
  PlayerInfo.addDodgeTimeout(builder, this.dodgeTimeout);
  PlayerInfo.addDemolishedTimeout(builder, this.demolishedTimeout);
  PlayerInfo.addIsSupersonic(builder, this.isSupersonic);
  PlayerInfo.addIsBot(builder, this.isBot);
  PlayerInfo.addName(builder, name);
  PlayerInfo.addTeam(builder, this.team);
  PlayerInfo.addBoost(builder, this.boost);
  PlayerInfo.addPlayerId(builder, this.playerId);
  PlayerInfo.addAccolades(builder, accolades);
  PlayerInfo.addLastInput(builder, (this.lastInput !== null ? this.lastInput!.pack(builder) : 0));
  PlayerInfo.addHasJumped(builder, this.hasJumped);
  PlayerInfo.addHasDoubleJumped(builder, this.hasDoubleJumped);
  PlayerInfo.addHasDodged(builder, this.hasDodged);
  PlayerInfo.addDodgeElapsed(builder, this.dodgeElapsed);
  PlayerInfo.addDodgeDir(builder, (this.dodgeDir !== null ? this.dodgeDir!.pack(builder) : 0));

  return PlayerInfo.endPlayerInfo(builder);
}
}
