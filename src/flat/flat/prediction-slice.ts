// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Physics, PhysicsT } from '../../flat/flat/physics.js';


/**
 * An entry in the ball prediction describing where a ball will be at some future time.
 */
export class PredictionSlice implements flatbuffers.IUnpackableObject<PredictionSliceT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PredictionSlice {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

/**
 * The moment in game time that this prediction corresponds to.
 * This corresponds to 'seconds_elapsed' in the MatchInfo.
 */
gameSeconds():number {
  return this.bb!.readFloat32(this.bb_pos);
}

/**
 * The predicted location and motion of the object.
 */
physics(obj?:Physics):Physics|null {
  return (obj || new Physics()).__init(this.bb_pos + 4, this.bb!);
}

static sizeOf():number {
  return 52;
}

static createPredictionSlice(builder:flatbuffers.Builder, game_seconds: number, physics_location_x: number, physics_location_y: number, physics_location_z: number, physics_rotation_pitch: number, physics_rotation_yaw: number, physics_rotation_roll: number, physics_velocity_x: number, physics_velocity_y: number, physics_velocity_z: number, physics_angular_velocity_x: number, physics_angular_velocity_y: number, physics_angular_velocity_z: number):flatbuffers.Offset {
  builder.prep(4, 52);
  builder.prep(4, 48);
  builder.prep(4, 12);
  builder.writeFloat32(physics_angular_velocity_z);
  builder.writeFloat32(physics_angular_velocity_y);
  builder.writeFloat32(physics_angular_velocity_x);
  builder.prep(4, 12);
  builder.writeFloat32(physics_velocity_z);
  builder.writeFloat32(physics_velocity_y);
  builder.writeFloat32(physics_velocity_x);
  builder.prep(4, 12);
  builder.writeFloat32(physics_rotation_roll);
  builder.writeFloat32(physics_rotation_yaw);
  builder.writeFloat32(physics_rotation_pitch);
  builder.prep(4, 12);
  builder.writeFloat32(physics_location_z);
  builder.writeFloat32(physics_location_y);
  builder.writeFloat32(physics_location_x);
  builder.writeFloat32(game_seconds);
  return builder.offset();
}


unpack(): PredictionSliceT {
  return new PredictionSliceT(
    this.gameSeconds(),
    (this.physics() !== null ? this.physics()!.unpack() : null)
  );
}


unpackTo(_o: PredictionSliceT): void {
  _o.gameSeconds = this.gameSeconds();
  _o.physics = (this.physics() !== null ? this.physics()!.unpack() : null);
}
}

export class PredictionSliceT implements flatbuffers.IGeneratedObject {
constructor(
  public gameSeconds: number = 0.0,
  public physics: PhysicsT|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return PredictionSlice.createPredictionSlice(builder,
    this.gameSeconds,
    (this.physics?.location?.x ?? 0),
    (this.physics?.location?.y ?? 0),
    (this.physics?.location?.z ?? 0),
    (this.physics?.rotation?.pitch ?? 0),
    (this.physics?.rotation?.yaw ?? 0),
    (this.physics?.rotation?.roll ?? 0),
    (this.physics?.velocity?.x ?? 0),
    (this.physics?.velocity?.y ?? 0),
    (this.physics?.velocity?.z ?? 0),
    (this.physics?.angularVelocity?.x ?? 0),
    (this.physics?.angularVelocity?.y ?? 0),
    (this.physics?.angularVelocity?.z ?? 0)
  );
}
}
