// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { DebugRendering } from '../../flat/flat/debug-rendering.js';
import { ExistingMatchBehavior } from '../../flat/flat/existing-match-behavior.js';
import { GameMode } from '../../flat/flat/game-mode.js';
import { Launcher } from '../../flat/flat/launcher.js';
import { MutatorSettings, MutatorSettingsT } from '../../flat/flat/mutator-settings.js';
import { PlayerConfiguration, PlayerConfigurationT } from '../../flat/flat/player-configuration.js';
import { ScriptConfiguration, ScriptConfigurationT } from '../../flat/flat/script-configuration.js';


/**
 * Definition of a match.
 * Can be sent to RLBot to request the start of a match.
 */
export class MatchConfiguration implements flatbuffers.IUnpackableObject<MatchConfigurationT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):MatchConfiguration {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMatchConfiguration(bb:flatbuffers.ByteBuffer, obj?:MatchConfiguration):MatchConfiguration {
  return (obj || new MatchConfiguration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMatchConfiguration(bb:flatbuffers.ByteBuffer, obj?:MatchConfiguration):MatchConfiguration {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchConfiguration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * How to launch Rocket League.
 * If left unset, RLBot will not launch the game.
 * To use Legendary, use Custom and set launcher_arg="legendary".
 */
launcher():Launcher {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Launcher.Steam;
}

/**
 * Additional configuration for the launching method.
 * See launcher.
 */
launcherArg():string|null
launcherArg(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
launcherArg(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * If true, RLBot will start the bots and scripts that has a non-empty run command in their player/script configuration.
 */
autoStartAgents():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
}

/**
 * If true, RLBot will start the match only once all bots and script have connected and are ready.
 * If false, the match will start as soon as the map loads.
 */
waitForAgents():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
}

/**
 * The name of a upk file, like UtopiaStadium_P, which should be loaded.
 * On Steam version of Rocket League this can be used to load custom map files,
 * but on Epic version it only works on the Psyonix maps.
 * Available maps can be found here: https://github.com/VirxEC/python-interface/blob/master/rlbot/utils/maps.py
 */
gameMapUpk():string|null
gameMapUpk(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
gameMapUpk(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The players in the match.
 */
playerConfigurations(index: number, obj?:PlayerConfiguration):PlayerConfiguration|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new PlayerConfiguration()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

playerConfigurationsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The custom scripts used in the match.
 */
scriptConfigurations(index: number, obj?:ScriptConfiguration):ScriptConfiguration|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new ScriptConfiguration()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

scriptConfigurationsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The game mode.
 * This affects a few of the game rules although many game modes can also be recreated solely from mutators.
 * See what mutators and game mode combinations make up the official modes at https://github.com/VirxEC/python-interface/tree/master/tests/gamemodes
 */
gameMode():GameMode {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : GameMode.Soccar;
}

/**
 * Whether to skip goal replays.
 */
skipReplays():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Whether to start without a kickoff countdown.
 */
instantStart():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Mutator settings.
 */
mutators(obj?:MutatorSettings):MutatorSettings|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? (obj || new MutatorSettings()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * How to handle any ongoing match.
 */
existingMatchBehavior():ExistingMatchBehavior {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : ExistingMatchBehavior.Restart;
}

/**
 * Whether debug rendering is displayed.
 */
enableRendering():DebugRendering {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : DebugRendering.OffByDefault;
}

/**
 * Whether clients are allowed to manipulate the game state, e.g. teleporting cars and ball.
 */
enableStateSetting():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
}

/**
 * Whether the match replay should be saved.
 */
autoSaveReplay():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * If set to true, a free play match is launched instead of an exhibition match.
 * This allows the players to use training keybinds, Bakkesmod plugins, and other features that are only allowed in free play.
 */
freeplay():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startMatchConfiguration(builder:flatbuffers.Builder) {
  builder.startObject(16);
}

static addLauncher(builder:flatbuffers.Builder, launcher:Launcher) {
  builder.addFieldInt8(0, launcher, Launcher.Steam);
}

static addLauncherArg(builder:flatbuffers.Builder, launcherArgOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, launcherArgOffset, 0);
}

static addAutoStartAgents(builder:flatbuffers.Builder, autoStartAgents:boolean) {
  builder.addFieldInt8(2, +autoStartAgents, +true);
}

static addWaitForAgents(builder:flatbuffers.Builder, waitForAgents:boolean) {
  builder.addFieldInt8(3, +waitForAgents, +true);
}

static addGameMapUpk(builder:flatbuffers.Builder, gameMapUpkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, gameMapUpkOffset, 0);
}

static addPlayerConfigurations(builder:flatbuffers.Builder, playerConfigurationsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, playerConfigurationsOffset, 0);
}

static createPlayerConfigurationsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startPlayerConfigurationsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addScriptConfigurations(builder:flatbuffers.Builder, scriptConfigurationsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, scriptConfigurationsOffset, 0);
}

static createScriptConfigurationsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startScriptConfigurationsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addGameMode(builder:flatbuffers.Builder, gameMode:GameMode) {
  builder.addFieldInt8(7, gameMode, GameMode.Soccar);
}

static addSkipReplays(builder:flatbuffers.Builder, skipReplays:boolean) {
  builder.addFieldInt8(8, +skipReplays, +false);
}

static addInstantStart(builder:flatbuffers.Builder, instantStart:boolean) {
  builder.addFieldInt8(9, +instantStart, +false);
}

static addMutators(builder:flatbuffers.Builder, mutatorsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, mutatorsOffset, 0);
}

static addExistingMatchBehavior(builder:flatbuffers.Builder, existingMatchBehavior:ExistingMatchBehavior) {
  builder.addFieldInt8(11, existingMatchBehavior, ExistingMatchBehavior.Restart);
}

static addEnableRendering(builder:flatbuffers.Builder, enableRendering:DebugRendering) {
  builder.addFieldInt8(12, enableRendering, DebugRendering.OffByDefault);
}

static addEnableStateSetting(builder:flatbuffers.Builder, enableStateSetting:boolean) {
  builder.addFieldInt8(13, +enableStateSetting, +true);
}

static addAutoSaveReplay(builder:flatbuffers.Builder, autoSaveReplay:boolean) {
  builder.addFieldInt8(14, +autoSaveReplay, +false);
}

static addFreeplay(builder:flatbuffers.Builder, freeplay:boolean) {
  builder.addFieldInt8(15, +freeplay, +false);
}

static endMatchConfiguration(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 6) // launcher_arg
  builder.requiredField(offset, 12) // game_map_upk
  builder.requiredField(offset, 14) // player_configurations
  builder.requiredField(offset, 16) // script_configurations
  return offset;
}


unpack(): MatchConfigurationT {
  return new MatchConfigurationT(
    this.launcher(),
    this.launcherArg(),
    this.autoStartAgents(),
    this.waitForAgents(),
    this.gameMapUpk(),
    this.bb!.createObjList<PlayerConfiguration, PlayerConfigurationT>(this.playerConfigurations.bind(this), this.playerConfigurationsLength()),
    this.bb!.createObjList<ScriptConfiguration, ScriptConfigurationT>(this.scriptConfigurations.bind(this), this.scriptConfigurationsLength()),
    this.gameMode(),
    this.skipReplays(),
    this.instantStart(),
    (this.mutators() !== null ? this.mutators()!.unpack() : null),
    this.existingMatchBehavior(),
    this.enableRendering(),
    this.enableStateSetting(),
    this.autoSaveReplay(),
    this.freeplay()
  );
}


unpackTo(_o: MatchConfigurationT): void {
  _o.launcher = this.launcher();
  _o.launcherArg = this.launcherArg();
  _o.autoStartAgents = this.autoStartAgents();
  _o.waitForAgents = this.waitForAgents();
  _o.gameMapUpk = this.gameMapUpk();
  _o.playerConfigurations = this.bb!.createObjList<PlayerConfiguration, PlayerConfigurationT>(this.playerConfigurations.bind(this), this.playerConfigurationsLength());
  _o.scriptConfigurations = this.bb!.createObjList<ScriptConfiguration, ScriptConfigurationT>(this.scriptConfigurations.bind(this), this.scriptConfigurationsLength());
  _o.gameMode = this.gameMode();
  _o.skipReplays = this.skipReplays();
  _o.instantStart = this.instantStart();
  _o.mutators = (this.mutators() !== null ? this.mutators()!.unpack() : null);
  _o.existingMatchBehavior = this.existingMatchBehavior();
  _o.enableRendering = this.enableRendering();
  _o.enableStateSetting = this.enableStateSetting();
  _o.autoSaveReplay = this.autoSaveReplay();
  _o.freeplay = this.freeplay();
}
}

export class MatchConfigurationT implements flatbuffers.IGeneratedObject {
constructor(
  public launcher: Launcher = Launcher.Steam,
  public launcherArg: string|Uint8Array|null = null,
  public autoStartAgents: boolean = true,
  public waitForAgents: boolean = true,
  public gameMapUpk: string|Uint8Array|null = null,
  public playerConfigurations: (PlayerConfigurationT)[] = [],
  public scriptConfigurations: (ScriptConfigurationT)[] = [],
  public gameMode: GameMode = GameMode.Soccar,
  public skipReplays: boolean = false,
  public instantStart: boolean = false,
  public mutators: MutatorSettingsT|null = null,
  public existingMatchBehavior: ExistingMatchBehavior = ExistingMatchBehavior.Restart,
  public enableRendering: DebugRendering = DebugRendering.OffByDefault,
  public enableStateSetting: boolean = true,
  public autoSaveReplay: boolean = false,
  public freeplay: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const launcherArg = (this.launcherArg !== null ? builder.createString(this.launcherArg!) : 0);
  const gameMapUpk = (this.gameMapUpk !== null ? builder.createString(this.gameMapUpk!) : 0);
  const playerConfigurations = MatchConfiguration.createPlayerConfigurationsVector(builder, builder.createObjectOffsetList(this.playerConfigurations));
  const scriptConfigurations = MatchConfiguration.createScriptConfigurationsVector(builder, builder.createObjectOffsetList(this.scriptConfigurations));
  const mutators = (this.mutators !== null ? this.mutators!.pack(builder) : 0);

  MatchConfiguration.startMatchConfiguration(builder);
  MatchConfiguration.addLauncher(builder, this.launcher);
  MatchConfiguration.addLauncherArg(builder, launcherArg);
  MatchConfiguration.addAutoStartAgents(builder, this.autoStartAgents);
  MatchConfiguration.addWaitForAgents(builder, this.waitForAgents);
  MatchConfiguration.addGameMapUpk(builder, gameMapUpk);
  MatchConfiguration.addPlayerConfigurations(builder, playerConfigurations);
  MatchConfiguration.addScriptConfigurations(builder, scriptConfigurations);
  MatchConfiguration.addGameMode(builder, this.gameMode);
  MatchConfiguration.addSkipReplays(builder, this.skipReplays);
  MatchConfiguration.addInstantStart(builder, this.instantStart);
  MatchConfiguration.addMutators(builder, mutators);
  MatchConfiguration.addExistingMatchBehavior(builder, this.existingMatchBehavior);
  MatchConfiguration.addEnableRendering(builder, this.enableRendering);
  MatchConfiguration.addEnableStateSetting(builder, this.enableStateSetting);
  MatchConfiguration.addAutoSaveReplay(builder, this.autoSaveReplay);
  MatchConfiguration.addFreeplay(builder, this.freeplay);

  return MatchConfiguration.endMatchConfiguration(builder);
}
}
