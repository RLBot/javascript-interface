// @ts-nocheck automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import { BallPrediction, BallPredictionT } from '../../flat/flat/ball-prediction.js';
import { ControllableTeamInfo, ControllableTeamInfoT } from '../../flat/flat/controllable-team-info.js';
import { DisconnectSignal, DisconnectSignalT } from '../../flat/flat/disconnect-signal.js';
import { FieldInfo, FieldInfoT } from '../../flat/flat/field-info.js';
import { GamePacket, GamePacketT } from '../../flat/flat/game-packet.js';
import { MatchComm, MatchCommT } from '../../flat/flat/match-comm.js';
import { MatchConfiguration, MatchConfigurationT } from '../../flat/flat/match-configuration.js';
import { PingRequest, PingRequestT } from '../../flat/flat/ping-request.js';
import { PingResponse, PingResponseT } from '../../flat/flat/ping-response.js';
import { RenderingStatus, RenderingStatusT } from '../../flat/flat/rendering-status.js';


/**
 * Messages sent from core to interfaces
 */
export enum CoreMessage {
  NONE = 0,

  /**
   * Interface should exit when this packet is received.
   */
  DisconnectSignal = 1,

  /**
   * Main game packet containing all relevant data.
   * Sent every tick once core has received InitComplete
   */
  GamePacket = 2,

  /**
   * Sent once core receives a valid ConnectionSettings from the interface
   */
  FieldInfo = 3,

  /**
   * Sent once core receives a valid MatchConfiguration from the interface
   */
  MatchConfiguration = 4,

  /**
   * Core relays matchcomms to bot agents in the same team if team_only is true
   */
  MatchComm = 5,

  /**
   * Prediction of ball trajectory
   */
  BallPrediction = 6,

  /**
   * Sent once core receives a valid ConnectionSettings from the interface
   */
  ControllableTeamInfo = 7,

  /**
   * An agent had its ability to render changed
   */
  RenderingStatus = 8,

  /**
   * Requests for client to send a PingResponse asap for measuring latency
   */
  PingRequest = 9,

  /**
   * Response to PingRequest for measuring latency
   */
  PingResponse = 10
}

export function unionToCoreMessage(
  type: CoreMessage,
  accessor: (obj:BallPrediction|ControllableTeamInfo|DisconnectSignal|FieldInfo|GamePacket|MatchComm|MatchConfiguration|PingRequest|PingResponse|RenderingStatus) => BallPrediction|ControllableTeamInfo|DisconnectSignal|FieldInfo|GamePacket|MatchComm|MatchConfiguration|PingRequest|PingResponse|RenderingStatus|null
): BallPrediction|ControllableTeamInfo|DisconnectSignal|FieldInfo|GamePacket|MatchComm|MatchConfiguration|PingRequest|PingResponse|RenderingStatus|null {
  switch(CoreMessage[type]) {
    case 'NONE': return null; 
    case 'DisconnectSignal': return accessor(new DisconnectSignal())! as DisconnectSignal;
    case 'GamePacket': return accessor(new GamePacket())! as GamePacket;
    case 'FieldInfo': return accessor(new FieldInfo())! as FieldInfo;
    case 'MatchConfiguration': return accessor(new MatchConfiguration())! as MatchConfiguration;
    case 'MatchComm': return accessor(new MatchComm())! as MatchComm;
    case 'BallPrediction': return accessor(new BallPrediction())! as BallPrediction;
    case 'ControllableTeamInfo': return accessor(new ControllableTeamInfo())! as ControllableTeamInfo;
    case 'RenderingStatus': return accessor(new RenderingStatus())! as RenderingStatus;
    case 'PingRequest': return accessor(new PingRequest())! as PingRequest;
    case 'PingResponse': return accessor(new PingResponse())! as PingResponse;
    default: return null;
  }
}

export function unionListToCoreMessage(
  type: CoreMessage, 
  accessor: (index: number, obj:BallPrediction|ControllableTeamInfo|DisconnectSignal|FieldInfo|GamePacket|MatchComm|MatchConfiguration|PingRequest|PingResponse|RenderingStatus) => BallPrediction|ControllableTeamInfo|DisconnectSignal|FieldInfo|GamePacket|MatchComm|MatchConfiguration|PingRequest|PingResponse|RenderingStatus|null, 
  index: number
): BallPrediction|ControllableTeamInfo|DisconnectSignal|FieldInfo|GamePacket|MatchComm|MatchConfiguration|PingRequest|PingResponse|RenderingStatus|null {
  switch(CoreMessage[type]) {
    case 'NONE': return null; 
    case 'DisconnectSignal': return accessor(index, new DisconnectSignal())! as DisconnectSignal;
    case 'GamePacket': return accessor(index, new GamePacket())! as GamePacket;
    case 'FieldInfo': return accessor(index, new FieldInfo())! as FieldInfo;
    case 'MatchConfiguration': return accessor(index, new MatchConfiguration())! as MatchConfiguration;
    case 'MatchComm': return accessor(index, new MatchComm())! as MatchComm;
    case 'BallPrediction': return accessor(index, new BallPrediction())! as BallPrediction;
    case 'ControllableTeamInfo': return accessor(index, new ControllableTeamInfo())! as ControllableTeamInfo;
    case 'RenderingStatus': return accessor(index, new RenderingStatus())! as RenderingStatus;
    case 'PingRequest': return accessor(index, new PingRequest())! as PingRequest;
    case 'PingResponse': return accessor(index, new PingResponse())! as PingResponse;
    default: return null;
  }
}
